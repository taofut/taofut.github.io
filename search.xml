<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jackson常用注解【servyou总结】]]></title>
    <url>%2F2019%2F05%2F22%2Fjackson%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[开发问题一（@JsonInclude的使用）在写后台接口回传数据到前端时，遇到一些细节问题，下面直接看代码。我要回传的对象类如下，从数据库查出来的任何类型数据都放data里参与序列化返回给前端。 12345678910@JsonInclude(JsonInclude.Include.NON_EMPTY)public class NewFrameResponseResult&lt;T&gt; &#123; private boolean success; private T data; private String error;&#125; 情况假设数据库查出来为null，那么data就是null，执行sql是没问题的，success返回true。由于类上面定义了@JsonInclude(JsonInclude.Include.NON_EMPTY)，所以data为null是不会在序列化结果中显示的。前端获取的返回结果：{“success”:true}，后面的js代码直接拿data报错，因为data根本不存在。改进这时候就面临一个问题，我数据库是没查到数据，但是data这个属性还是要返回的，因为这是前端js获取数据的唯一字段，可以在没数据的情况下返回一个空的data（数组长度为零，但不为null）。 1234567891011121314@JsonInclude(JsonInclude.Include.NON_NULL)public class NewFrameResponseResult&lt;T&gt; &#123; private boolean success; private T data; private String error; public static NewFrameResponseResult success(Object data) &#123; return new NewFrameResponseResult(data == null ? Collections.EMPTY_LIST : data); &#125;&#125; 这里允许返回空对象，所以注解就要变为@JsonInclude(JsonInclude.Include.NON_NULL)，然后在返回的方法里判断为null，就将data转换为空集合。前端获取的返回结果：{“success”: true,”data”: []}说明JsonInclude.Include.NON_EMPTY：属性为空或者null都不参与序列化。JsonInclude.Include.NON_NULL：属性为null不参与序列化。 开发问题二（@JsonIgnore和@JsonIgnoreProperties的使用）这次是将数据库查出来的菜单目录封装成树结构，有一个树节点实体TreeNode。由于查出来的数据在封装树的时候需要定义pid参与子节点遍历，但是前端返回结果中是不需要pid这个字段的，那么就在pid字段上加上注解@JsonIgnore，这样pid既参与了树结构的封装，同时也可以不让前端接收到。 123456789101112131415161718192021222324252627@JsonInclude(JsonInclude.Include.NON_EMPTY)public class TreeNode &#123; //根节点类型 public static final String NODE_TYPE_ROOT = "ROOT"; //父节点类型（下面还存在子节点） public static final String NODE_TYPE_GROUP = "GROUP"; //子节点类型（只有子节点） public static final String NODE_TYPE_LEAF = "LEAF"; //节点名称 private String name; //节点id private String nodeId; //节点类型 private String nodeType; //图标 private String className = "iconfont"; //节点url private String url; //父节点id @JsonIgnore private String pid; //当前节点下的子节点 private List&lt;TreeNode&gt; children; //菜单状态Hot（标记点击量高的菜单） private String otherInfo;&#125; 说明@JsonIgnore（作用在属性或方法）：用来告诉Jackson在处理时忽略该注解标注的 java pojo 属性。@JsonIgnoreProperties（作用在类）：@JsonIgnoreProperties和@JsonIgnore的作用相同，都是告诉Jackson该忽略哪些属性，不同之处是@JsonIgnoreProperties是类级别的，并且可以同时指定多个属性。 1234567891011121314151617181920212223242526@JsonIgnoreProperties(value = &#123;"pid","nodeType"&#125;)public class TreeNode &#123; //根节点类型 public static final String NODE_TYPE_ROOT = "ROOT"; //父节点类型（下面还存在子节点） public static final String NODE_TYPE_GROUP = "GROUP"; //子节点类型（只有子节点） public static final String NODE_TYPE_LEAF = "LEAF"; //节点名称 private String name; //节点id private String nodeId; //节点类型 private String nodeType; //图标 private String className = "iconfont"; //节点url private String url; //父节点id private String pid; //当前节点下的子节点 private List&lt;TreeNode&gt; children; //菜单状态Hot（标记点击量高的菜单） private String otherInfo;&#125; @JsonIgnoreType的使用@JsonIgnoreType标注在类上，当其他类引用该类时，该属性将被忽略。 12345678910111213141516@JsonIgnoreTypepublic class User &#123; private Long id; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125;&#125;public class Role &#123; private String name; private String desc; private User user;&#125;]]></content>
      <categories>
        <category>开发中常用注解</category>
      </categories>
      <tags>
        <tag>servyou总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@RequestParam和@RequestBody的区别【servyou总结】]]></title>
    <url>%2F2019%2F05%2F21%2F%40RequestParam%E5%92%8C%40RequestBody%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[最近在公司写后台接口供前端调用，代码都是按照接口文档的要求实现的，并且自己用postman测试了一遍，参数取值都OK。接口文档的参数传递方式为：{xtdm:’001’}，请求方式都是POST，然后我就自然而然的采用了application/json方式测试。采用application/json方式测试接口之后，发现后台springmvc接收参数使用@RequestParam注解是取不到值的，于是我换成@RequestBody注解就取到值了，当时问题解决。后面整合前端联调接口时，发现前端请求到不了我的controller（http:400），但是postman始终是可以的。看了下前端的ajax请求，发现并不是按照文档的格式传递的参数。虽然是POST请求，但是地址栏也会跟参数过来，于是我尝试把@RequestBody又改为@RequestParam，结果又可以了，然后postman又不行了。 分析和结论我开始采用application/json方式测试，@RequestBody是支持的，后来发现前端的请求方式其实是application/x-www-form-urlencoded，所以@RequestBody就不支持了。只有@RequestParam才支持，并且不管是POST还是GET请求都是OK的。后来我将postman请求方式改为application/x-www-form-urlencoded，验证结果跟前端的一致。所以不要着急写后台接口，一定要明确前端的请求方式是哪一种，这样就避免了返工的情况。 @RequestParam和@RequestBody的使用场景@RequestParam① 支持POST和GET请求。② 只支持Content-Type：为application/x-www-form-urlencoded编码的内容。Http协议中，如果不指定Content-Type，则默认传递的参数就是application/x-www-form-urlencoded类型） @RequestBody① 不支持GET请求。② 必须要在请求头中申明content-Type（如application/json）springMvc通过HandlerAdapter配置的HttpMessageConverters解析httpEntity的数据，并绑定到相应的bean上。 @RequestParam案例使用@RequestParm用于绑定controller上的参数，可以是多个参数，也可以是一个Map集合，GET，POST均可。 123456@PostMapping(value = "requestParam")@ResponseBodypublic Boolean requestParam(@RequestParam(name = "code",required = false) String code)&#123; System.out.println("code:"+code); return true;&#125; @RequestParm中name属性是指定参数名，required属性默认为ture，表示必传。若为false则为非必传。属性有defaultValue默认值选项，若该参数为null时，会将默认值填充到参数上。在项目中还可以使用map来接收多个参数： 1234@RequestMapping(value = "/menu.spring",method = RequestMethod.POST)public NewFrameResponseResult queryTreeList(@RequestParam Map&lt;String, Object&gt; param)&#123; return NewFrameResponseResult.success(fyhsMenuTreeService.queryTreeList(param));&#125; @RequestBody案例@RequestBody绑定一个实体。 123456@PostMapping(value = "requestBody")@ResponseBodypublic User requestBody(@RequestBody User user)&#123; System.out.println("user:"+user.getName()); return user;&#125; @RequestBody也能采用map来接收多个参数。 1234@RequestMapping(value = "/menu.spring",method = RequestMethod.POST)public NewFrameResponseResult queryTreeList(@RequestBody Map&lt;String, Object&gt; param)&#123; return NewFrameResponseResult.success(fyhsMenuTreeService.queryTreeList(param));&#125;]]></content>
      <categories>
        <category>开发中常用注解</category>
      </categories>
      <tags>
        <tag>servyou总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@Bean的用法]]></title>
    <url>%2F2019%2F05%2F20%2F%E6%B3%A8%E8%A7%A3%40bean%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[@Bean是一个方法级别上的注解，主要用在@Configuration注解的类里，也可以用在@Component注解的类里，添加的bean的id为方法名。 案例下面是@Configuration里的一个例子。 12345678910111213@Configurationpublic class Configure &#123; @Bean public FilterRegistrationBean registLog() &#123; FilterRegistrationBean loggingFilter = new FilterRegistrationBean(new LoggingFilter()); loggingFilter.addUrlPatterns("/*"); loggingFilter.setName("LoggingFilter"); loggingFilter.setOrder(5); return loggingFilter; &#125;&#125; 这个配置就等同于之前在xml里的配置 123&lt;beans&gt; &lt;bean id="registLog" class="org.springframework.boot.web.servlet.FilterRegistrationBean"/&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>开发中常用注解</category>
      </categories>
      <tags>
        <tag>编程，感悟</tag>
      </tags>
  </entry>
</search>
